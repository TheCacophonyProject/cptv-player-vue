{"version":3,"sources":["webpack://CptvPlayerVue/webpack/bootstrap","webpack://CptvPlayerVue/webpack/runtime/hasOwnProperty shorthand","webpack://CptvPlayerVue/webpack/runtime/publicPath","webpack://CptvPlayerVue/webpack/runtime/importScripts chunk loading","webpack://CptvPlayerVue/./node_modules/cptv-decoder/pkg/index.js","webpack://CptvPlayerVue/./node_modules/cptv-decoder/decoder.js","webpack://CptvPlayerVue/./node_modules/cptv-decoder/decoder.worker.js"],"names":["__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","exports","module","__webpack_modules__","m","o","obj","prop","Object","prototype","hasOwnProperty","call","p","b","self","location","wasm","heap","Array","fill","getObject","idx","push","heap_next","length","dropObject","takeObject","ret","addHeapObject","cachedTextDecoder","TextDecoder","ignoreBOM","fatal","decode","cachegetUint8Memory0","getUint8Memory0","buffer","memory","Uint8Array","getStringFromWasm0","ptr","len","subarray","debugString","val","type","description","name","isArray","debug","i","builtInMatches","exec","toString","className","JSON","stringify","_","Error","message","stack","WASM_VECTOR_LEN","cachedTextEncoder","TextEncoder","encodeString","encodeInto","arg","view","buf","encode","set","read","written","passStringToWasm0","malloc","realloc","mem","offset","code","charCodeAt","slice","cachegetInt32Memory0","getInt32Memory0","Int32Array","makeMutClosure","arg0","arg1","dtor","f","state","a","cnt","real","args","__wbindgen_export_2","get","original","__wbg_adapter_22","arg2","_dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h58f26b25ebd66e81","handleError","apply","this","arguments","e","__wbindgen_exn_store","_assertClass","instance","klass","__wbg_adapter_51","arg3","wasm_bindgen__convert__closures__invoke2_mut__h8c76bc75b4ce3cb1","CptvPlayerContext","create","__destroy_into_raw","__wbg_cptvplayercontext_free","stream","cptvplayercontext_newWithStream","cptvplayercontext_streamComplete","context","ptr0","cptvplayercontext_countTotalFrames","cptvplayercontext_fetchNextFrame","cptvplayercontext_totalFrames","cptvplayercontext_bytesLoaded","cptvplayercontext_getNextFrame","cptvplayercontext_getFrameHeader","cptvplayercontext_getWidth","cptvplayercontext_getHeight","cptvplayercontext_getFrameRate","cptvplayercontext_getFramesPerIframe","cptvplayercontext_fetchHeader","cptvplayercontext_getHeader","async","load","imports","Response","WebAssembly","instantiateStreaming","headers","console","warn","bytes","arrayBuffer","instantiate","Instance","init","input","URL","wbg","__wbindgen_object_drop_ref","__wbg_new_3ea8490cd276c848","state0","cb0","Promise","__wbindgen_number_new","__wbg_newwithlength_90fbb2b2d057a3c0","Uint16Array","__wbindgen_memory","__wbg_buffer_ebc6c8e75510eae3","__wbg_newwithbyteoffsetandlength_9eb3327abeac2c52","__wbg_new_68adb0d58759a4ed","__wbg_set_2e79e744454afade","__wbindgen_string_new","__wbg_new_59cb74e423758ede","__wbg_stack_558ba5917b466edd","__wbindgen_malloc","__wbindgen_realloc","len0","__wbg_error_4bb6c2a97407129a","error","__wbindgen_free","__wbg_read_2516fe8e4e56274e","__wbg_then_ac66ca61394bfd21","then","__wbindgen_boolean_get","v","__wbindgen_is_undefined","__wbg_instanceof_Uint8Array_d7349a138407a31e","__wbg_byteLength_7d55aca7ec6c42cb","byteLength","__wbg_length_317f0dd77f7a6673","__wbg_new_135e963dedf67b22","__wbg_set_4a5072a31008e0cb","__wbg_cptvplayercontext_new","__wrap","__wbg_call_f5e0576f61ee7461","__wbg_get_0c6963cbab34fbb6","Reflect","__wbg_new_7031805939a80203","__wbindgen_object_clone_ref","__wbindgen_debug_string","__wbindgen_throw","__wbg_then_367b3e718069cfb9","__wbindgen_cb_drop","__wbg_resolve_778af3f90b8e2b59","resolve","__wbg_debug_3c0b82934d1dd91e","__wbg_error_9ff84d33a850b1ef","__wbg_info_3b2058a219fa31b9","info","__wbg_log_386a8115a84a780d","log","__wbg_warn_5fc232d538408d4a","__wbindgen_closure_wrapper211","Request","fetch","__wbindgen_wasm_module","Unlocker","fn","FakeReader","maxChunkSize","offsets","numParts","Math","ceil","percentages","value","done","initedWasm","CptvDecoderInterface","url","size","unlocker","lockIsUncontended","locked","inited","playerContext","free","reader","cancel","consumed","response","status","body","getReader","Number","expectedSize","unlock","r","json","messages","pop","text","filePath","file","require","createRequire","path","initWithFileBytes","fileBytes","frameData","getNextFrame","frameHeader","getFrameHeader","data","meta","getTotalFrames","header","getHeader","totalFrameCount","countTotalFrames","duration","fps","initWithCptvFile","getMetadata","initWithCptvUrlAndSize","streamComplete","totalFrames","bytesLoaded","parentPort","player","addEventListener","result","postMessage","getFileMetadata","getStreamMetadata","frame","fetchNextFrame","progress","getLoadProgress"],"mappings":"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","file":"decoder.worker.38da8bce3e7853c8b630.worker.js","sourcesContent":["// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n// expose the modules object (__webpack_modules__)\n__webpack_require__.m = __webpack_modules__;\n\n","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","__webpack_require__.p = \"\";","__webpack_require__.b = self.location + \"\";\n\n// object to store loaded chunks\n// \"1\" means \"already loaded\"\nvar installedChunks = {\n\t794: 1\n};\n\n// no chunk install function needed\n// no chunk loading\n\n// no HMR\n\n// no HMR manifest","\nlet wasm;\n\nconst heap = new Array(32).fill(undefined);\n\nheap.push(undefined, null, true, false);\n\nfunction getObject(idx) { return heap[idx]; }\n\nlet heap_next = heap.length;\n\nfunction dropObject(idx) {\n    if (idx < 36) return;\n    heap[idx] = heap_next;\n    heap_next = idx;\n}\n\nfunction takeObject(idx) {\n    const ret = getObject(idx);\n    dropObject(idx);\n    return ret;\n}\n\nfunction addHeapObject(obj) {\n    if (heap_next === heap.length) heap.push(heap.length + 1);\n    const idx = heap_next;\n    heap_next = heap[idx];\n\n    heap[idx] = obj;\n    return idx;\n}\n\nlet cachedTextDecoder = new TextDecoder('utf-8', { ignoreBOM: true, fatal: true });\n\ncachedTextDecoder.decode();\n\nlet cachegetUint8Memory0 = null;\nfunction getUint8Memory0() {\n    if (cachegetUint8Memory0 === null || cachegetUint8Memory0.buffer !== wasm.memory.buffer) {\n        cachegetUint8Memory0 = new Uint8Array(wasm.memory.buffer);\n    }\n    return cachegetUint8Memory0;\n}\n\nfunction getStringFromWasm0(ptr, len) {\n    return cachedTextDecoder.decode(getUint8Memory0().subarray(ptr, ptr + len));\n}\n\nfunction debugString(val) {\n    // primitive types\n    const type = typeof val;\n    if (type == 'number' || type == 'boolean' || val == null) {\n        return  `${val}`;\n    }\n    if (type == 'string') {\n        return `\"${val}\"`;\n    }\n    if (type == 'symbol') {\n        const description = val.description;\n        if (description == null) {\n            return 'Symbol';\n        } else {\n            return `Symbol(${description})`;\n        }\n    }\n    if (type == 'function') {\n        const name = val.name;\n        if (typeof name == 'string' && name.length > 0) {\n            return `Function(${name})`;\n        } else {\n            return 'Function';\n        }\n    }\n    // objects\n    if (Array.isArray(val)) {\n        const length = val.length;\n        let debug = '[';\n        if (length > 0) {\n            debug += debugString(val[0]);\n        }\n        for(let i = 1; i < length; i++) {\n            debug += ', ' + debugString(val[i]);\n        }\n        debug += ']';\n        return debug;\n    }\n    // Test for built-in\n    const builtInMatches = /\\[object ([^\\]]+)\\]/.exec(toString.call(val));\n    let className;\n    if (builtInMatches.length > 1) {\n        className = builtInMatches[1];\n    } else {\n        // Failed to match the standard '[object ClassName]'\n        return toString.call(val);\n    }\n    if (className == 'Object') {\n        // we're a user defined class or Object\n        // JSON.stringify avoids problems with cycles, and is generally much\n        // easier than looping through ownProperties of `val`.\n        try {\n            return 'Object(' + JSON.stringify(val) + ')';\n        } catch (_) {\n            return 'Object';\n        }\n    }\n    // errors\n    if (val instanceof Error) {\n        return `${val.name}: ${val.message}\\n${val.stack}`;\n    }\n    // TODO we could test for more things here, like `Set`s and `Map`s.\n    return className;\n}\n\nlet WASM_VECTOR_LEN = 0;\n\nlet cachedTextEncoder = new TextEncoder('utf-8');\n\nconst encodeString = (typeof cachedTextEncoder.encodeInto === 'function'\n    ? function (arg, view) {\n    return cachedTextEncoder.encodeInto(arg, view);\n}\n    : function (arg, view) {\n    const buf = cachedTextEncoder.encode(arg);\n    view.set(buf);\n    return {\n        read: arg.length,\n        written: buf.length\n    };\n});\n\nfunction passStringToWasm0(arg, malloc, realloc) {\n\n    if (realloc === undefined) {\n        const buf = cachedTextEncoder.encode(arg);\n        const ptr = malloc(buf.length);\n        getUint8Memory0().subarray(ptr, ptr + buf.length).set(buf);\n        WASM_VECTOR_LEN = buf.length;\n        return ptr;\n    }\n\n    let len = arg.length;\n    let ptr = malloc(len);\n\n    const mem = getUint8Memory0();\n\n    let offset = 0;\n\n    for (; offset < len; offset++) {\n        const code = arg.charCodeAt(offset);\n        if (code > 0x7F) break;\n        mem[ptr + offset] = code;\n    }\n\n    if (offset !== len) {\n        if (offset !== 0) {\n            arg = arg.slice(offset);\n        }\n        ptr = realloc(ptr, len, len = offset + arg.length * 3);\n        const view = getUint8Memory0().subarray(ptr + offset, ptr + len);\n        const ret = encodeString(arg, view);\n\n        offset += ret.written;\n    }\n\n    WASM_VECTOR_LEN = offset;\n    return ptr;\n}\n\nlet cachegetInt32Memory0 = null;\nfunction getInt32Memory0() {\n    if (cachegetInt32Memory0 === null || cachegetInt32Memory0.buffer !== wasm.memory.buffer) {\n        cachegetInt32Memory0 = new Int32Array(wasm.memory.buffer);\n    }\n    return cachegetInt32Memory0;\n}\n\nfunction makeMutClosure(arg0, arg1, dtor, f) {\n    const state = { a: arg0, b: arg1, cnt: 1, dtor };\n    const real = (...args) => {\n        // First up with a closure we increment the internal reference\n        // count. This ensures that the Rust closure environment won't\n        // be deallocated while we're invoking it.\n        state.cnt++;\n        const a = state.a;\n        state.a = 0;\n        try {\n            return f(a, state.b, ...args);\n        } finally {\n            if (--state.cnt === 0) {\n                wasm.__wbindgen_export_2.get(state.dtor)(a, state.b);\n\n            } else {\n                state.a = a;\n            }\n        }\n    };\n    real.original = state;\n\n    return real;\n}\nfunction __wbg_adapter_22(arg0, arg1, arg2) {\n    wasm._dyn_core__ops__function__FnMut__A____Output___R_as_wasm_bindgen__closure__WasmClosure___describe__invoke__h58f26b25ebd66e81(arg0, arg1, addHeapObject(arg2));\n}\n\nfunction handleError(f) {\n    return function () {\n        try {\n            return f.apply(this, arguments);\n\n        } catch (e) {\n            wasm.__wbindgen_exn_store(addHeapObject(e));\n        }\n    };\n}\n\nfunction _assertClass(instance, klass) {\n    if (!(instance instanceof klass)) {\n        throw new Error(`expected instance of ${klass.name}`);\n    }\n    return instance.ptr;\n}\nfunction __wbg_adapter_51(arg0, arg1, arg2, arg3) {\n    wasm.wasm_bindgen__convert__closures__invoke2_mut__h8c76bc75b4ce3cb1(arg0, arg1, addHeapObject(arg2), addHeapObject(arg3));\n}\n\n/**\n*/\nexport class CptvPlayerContext {\n\n    static __wrap(ptr) {\n        const obj = Object.create(CptvPlayerContext.prototype);\n        obj.ptr = ptr;\n\n        return obj;\n    }\n\n    __destroy_into_raw() {\n        const ptr = this.ptr;\n        this.ptr = 0;\n\n        return ptr;\n    }\n\n    free() {\n        const ptr = this.__destroy_into_raw();\n        wasm.__wbg_cptvplayercontext_free(ptr);\n    }\n    /**\n    * @param {any} stream\n    * @returns {any}\n    */\n    static newWithStream(stream) {\n        var ret = wasm.cptvplayercontext_newWithStream(addHeapObject(stream));\n        return takeObject(ret);\n    }\n    /**\n    * @returns {boolean}\n    */\n    streamComplete() {\n        var ret = wasm.cptvplayercontext_streamComplete(this.ptr);\n        return ret !== 0;\n    }\n    /**\n    * @param {CptvPlayerContext} context\n    * @returns {any}\n    */\n    static countTotalFrames(context) {\n        _assertClass(context, CptvPlayerContext);\n        var ptr0 = context.ptr;\n        context.ptr = 0;\n        var ret = wasm.cptvplayercontext_countTotalFrames(ptr0);\n        return takeObject(ret);\n    }\n    /**\n    * @param {CptvPlayerContext} context\n    * @returns {any}\n    */\n    static fetchNextFrame(context) {\n        _assertClass(context, CptvPlayerContext);\n        var ptr0 = context.ptr;\n        context.ptr = 0;\n        var ret = wasm.cptvplayercontext_fetchNextFrame(ptr0);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {any}\n    */\n    totalFrames() {\n        var ret = wasm.cptvplayercontext_totalFrames(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    bytesLoaded() {\n        var ret = wasm.cptvplayercontext_bytesLoaded(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {Uint16Array}\n    */\n    getNextFrame() {\n        var ret = wasm.cptvplayercontext_getNextFrame(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {any}\n    */\n    getFrameHeader() {\n        var ret = wasm.cptvplayercontext_getFrameHeader(this.ptr);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {number}\n    */\n    getWidth() {\n        var ret = wasm.cptvplayercontext_getWidth(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    getHeight() {\n        var ret = wasm.cptvplayercontext_getHeight(this.ptr);\n        return ret >>> 0;\n    }\n    /**\n    * @returns {number}\n    */\n    getFrameRate() {\n        var ret = wasm.cptvplayercontext_getFrameRate(this.ptr);\n        return ret;\n    }\n    /**\n    * @returns {number}\n    */\n    getFramesPerIframe() {\n        var ret = wasm.cptvplayercontext_getFramesPerIframe(this.ptr);\n        return ret;\n    }\n    /**\n    * @param {CptvPlayerContext} context\n    * @returns {any}\n    */\n    static fetchHeader(context) {\n        _assertClass(context, CptvPlayerContext);\n        var ptr0 = context.ptr;\n        context.ptr = 0;\n        var ret = wasm.cptvplayercontext_fetchHeader(ptr0);\n        return takeObject(ret);\n    }\n    /**\n    * @returns {any}\n    */\n    getHeader() {\n        var ret = wasm.cptvplayercontext_getHeader(this.ptr);\n        return takeObject(ret);\n    }\n}\n\nasync function load(module, imports) {\n    if (typeof Response === 'function' && module instanceof Response) {\n        if (typeof WebAssembly.instantiateStreaming === 'function') {\n            try {\n                return await WebAssembly.instantiateStreaming(module, imports);\n\n            } catch (e) {\n                if (module.headers.get('Content-Type') != 'application/wasm') {\n                    console.warn(\"`WebAssembly.instantiateStreaming` failed because your server does not serve wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\\n\", e);\n\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        const bytes = await module.arrayBuffer();\n        return await WebAssembly.instantiate(bytes, imports);\n\n    } else {\n        const instance = await WebAssembly.instantiate(module, imports);\n\n        if (instance instanceof WebAssembly.Instance) {\n            return { instance, module };\n\n        } else {\n            return instance;\n        }\n    }\n}\n\nasync function init(input) {\n    if (typeof input === 'undefined') {\n        input = new URL('index_bg.wasm', import.meta.url);\n    }\n    const imports = {};\n    imports.wbg = {};\n    imports.wbg.__wbindgen_object_drop_ref = function(arg0) {\n        takeObject(arg0);\n    };\n    imports.wbg.__wbg_new_3ea8490cd276c848 = function(arg0, arg1) {\n        try {\n            var state0 = {a: arg0, b: arg1};\n            var cb0 = (arg0, arg1) => {\n                const a = state0.a;\n                state0.a = 0;\n                try {\n                    return __wbg_adapter_51(a, state0.b, arg0, arg1);\n                } finally {\n                    state0.a = a;\n                }\n            };\n            var ret = new Promise(cb0);\n            return addHeapObject(ret);\n        } finally {\n            state0.a = state0.b = 0;\n        }\n    };\n    imports.wbg.__wbindgen_number_new = function(arg0) {\n        var ret = arg0;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithlength_90fbb2b2d057a3c0 = function(arg0) {\n        var ret = new Uint16Array(arg0 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_memory = function() {\n        var ret = wasm.memory;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_buffer_ebc6c8e75510eae3 = function(arg0) {\n        var ret = getObject(arg0).buffer;\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_newwithbyteoffsetandlength_9eb3327abeac2c52 = function(arg0, arg1, arg2) {\n        var ret = new Uint16Array(getObject(arg0), arg1 >>> 0, arg2 >>> 0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_68adb0d58759a4ed = function() {\n        var ret = new Object();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_2e79e744454afade = function(arg0, arg1, arg2) {\n        getObject(arg0)[takeObject(arg1)] = takeObject(arg2);\n    };\n    imports.wbg.__wbindgen_string_new = function(arg0, arg1) {\n        var ret = getStringFromWasm0(arg0, arg1);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_new_59cb74e423758ede = function() {\n        var ret = new Error();\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_stack_558ba5917b466edd = function(arg0, arg1) {\n        var ret = getObject(arg1).stack;\n        var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbg_error_4bb6c2a97407129a = function(arg0, arg1) {\n        try {\n            console.error(getStringFromWasm0(arg0, arg1));\n        } finally {\n            wasm.__wbindgen_free(arg0, arg1);\n        }\n    };\n    imports.wbg.__wbg_read_2516fe8e4e56274e = handleError(function(arg0) {\n        var ret = getObject(arg0).read();\n        return addHeapObject(ret);\n    });\n    imports.wbg.__wbg_then_ac66ca61394bfd21 = function(arg0, arg1, arg2) {\n        var ret = getObject(arg0).then(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_boolean_get = function(arg0) {\n        const v = getObject(arg0);\n        var ret = typeof(v) === 'boolean' ? (v ? 1 : 0) : 2;\n        return ret;\n    };\n    imports.wbg.__wbindgen_is_undefined = function(arg0) {\n        var ret = getObject(arg0) === undefined;\n        return ret;\n    };\n    imports.wbg.__wbg_instanceof_Uint8Array_d7349a138407a31e = function(arg0) {\n        var ret = getObject(arg0) instanceof Uint8Array;\n        return ret;\n    };\n    imports.wbg.__wbg_byteLength_7d55aca7ec6c42cb = function(arg0) {\n        var ret = getObject(arg0).byteLength;\n        return ret;\n    };\n    imports.wbg.__wbg_length_317f0dd77f7a6673 = function(arg0) {\n        var ret = getObject(arg0).length;\n        return ret;\n    };\n    imports.wbg.__wbg_new_135e963dedf67b22 = function(arg0) {\n        var ret = new Uint8Array(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_set_4a5072a31008e0cb = function(arg0, arg1, arg2) {\n        getObject(arg0).set(getObject(arg1), arg2 >>> 0);\n    };\n    imports.wbg.__wbg_cptvplayercontext_new = function(arg0) {\n        var ret = CptvPlayerContext.__wrap(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_call_f5e0576f61ee7461 = handleError(function(arg0, arg1, arg2) {\n        var ret = getObject(arg0).call(getObject(arg1), getObject(arg2));\n        return addHeapObject(ret);\n    });\n    imports.wbg.__wbg_get_0c6963cbab34fbb6 = handleError(function(arg0, arg1) {\n        var ret = Reflect.get(getObject(arg0), getObject(arg1));\n        return addHeapObject(ret);\n    });\n    imports.wbg.__wbg_new_7031805939a80203 = function(arg0, arg1) {\n        var ret = new Error(getStringFromWasm0(arg0, arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_object_clone_ref = function(arg0) {\n        var ret = getObject(arg0);\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_debug_string = function(arg0, arg1) {\n        var ret = debugString(getObject(arg1));\n        var ptr0 = passStringToWasm0(ret, wasm.__wbindgen_malloc, wasm.__wbindgen_realloc);\n        var len0 = WASM_VECTOR_LEN;\n        getInt32Memory0()[arg0 / 4 + 1] = len0;\n        getInt32Memory0()[arg0 / 4 + 0] = ptr0;\n    };\n    imports.wbg.__wbindgen_throw = function(arg0, arg1) {\n        throw new Error(getStringFromWasm0(arg0, arg1));\n    };\n    imports.wbg.__wbg_then_367b3e718069cfb9 = function(arg0, arg1) {\n        var ret = getObject(arg0).then(getObject(arg1));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbindgen_cb_drop = function(arg0) {\n        const obj = takeObject(arg0).original;\n        if (obj.cnt-- == 1) {\n            obj.a = 0;\n            return true;\n        }\n        var ret = false;\n        return ret;\n    };\n    imports.wbg.__wbg_resolve_778af3f90b8e2b59 = function(arg0) {\n        var ret = Promise.resolve(getObject(arg0));\n        return addHeapObject(ret);\n    };\n    imports.wbg.__wbg_debug_3c0b82934d1dd91e = function(arg0) {\n        console.debug(getObject(arg0));\n    };\n    imports.wbg.__wbg_error_9ff84d33a850b1ef = function(arg0) {\n        console.error(getObject(arg0));\n    };\n    imports.wbg.__wbg_info_3b2058a219fa31b9 = function(arg0) {\n        console.info(getObject(arg0));\n    };\n    imports.wbg.__wbg_log_386a8115a84a780d = function(arg0) {\n        console.log(getObject(arg0));\n    };\n    imports.wbg.__wbg_warn_5fc232d538408d4a = function(arg0) {\n        console.warn(getObject(arg0));\n    };\n    imports.wbg.__wbindgen_closure_wrapper211 = function(arg0, arg1, arg2) {\n        var ret = makeMutClosure(arg0, arg1, 49, __wbg_adapter_22);\n        return addHeapObject(ret);\n    };\n\n    if (typeof input === 'string' || (typeof Request === 'function' && input instanceof Request) || (typeof URL === 'function' && input instanceof URL)) {\n        input = fetch(input);\n    }\n\n\n\n    const { instance, module } = await load(await input, imports);\n\n    wasm = instance.exports;\n    init.__wbindgen_wasm_module = module;\n\n    return wasm;\n}\n\nexport default init;\n\n","import * as cptvPlayer from \"./pkg/index.js\";\n/**\n * NOTE: For browser usage, these imports need to be stubbed\n *  out in your webpack config using:\n *\n * resolve: {\n *  fallback: {\n *    fs,\n *    module,\n *  }\n * }\n */\n\nimport fs from \"fs/promises\";\nimport { createRequire } from \"module\";\n\nclass Unlocker {\n  constructor() {\n    this.fn = null;\n  }\n  unlock() {\n    this.fn && this.fn();\n  }\n}\n\n// For use in nodejs to wrap an already loaded array buffer into a Reader interface\nconst FakeReader = function (bytes, maxChunkSize) {\n  const state = {\n    offsets: []\n  };\n  state.bytes = bytes;\n  state.offset = 0;\n  const length = bytes.byteLength;\n  // How many reader chunks to split the file into\n  let numParts = 5;\n  if (maxChunkSize !== 0) {\n    numParts = Math.ceil(length / maxChunkSize);\n  }\n  const percentages = length / numParts;\n  for (let i = 0; i < numParts; i++) {\n    state.offsets.push(Math.ceil(percentages * i));\n  }\n  state.offsets.push(length);\n  return {\n    read() {\n      return new Promise((resolve) => {\n        state.offset += 1;\n        const value = state.bytes.slice(state.offsets[state.offset - 1], state.offsets[state.offset]);\n        resolve({\n          value,\n          done: state.offset === state.offsets.length - 1\n        });\n      });\n    },\n    cancel() {\n      // Does nothing.\n      return new Promise((resolve) => {\n        resolve()\n      });\n    }\n  }\n};\n\n// TODO(jon): This differs depending on whether the sensor is lepton 3 or 3.5\n// TODO(jon): This is probably out of scope for this library, should be handled\n//  at the player level.\nlet initedWasm = false;\n\nexport class CptvDecoderInterface {\n  async initWithCptvUrlAndSize(url, size) {\n    const unlocker = new Unlocker();\n    await this.lockIsUncontended(unlocker);\n    this.locked = true;\n    if (!initedWasm) {\n      await cptvPlayer.default();\n      initedWasm = true;\n    } else if (initedWasm && this.inited) {\n      this.playerContext.free();\n      this.reader && await this.reader.cancel();\n    }\n    try {\n      // Use this expired JWT token to test that failure case (usually when a page has been open too long)\n      //const oldJWT = \"https://api.cacophony.org.nz/api/v1/signedUrl?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfdHlwZSI6ImZpbGVEb3dubG9hZCIsImtleSI6InJhdy8yMDIxLzA0LzE1LzQ3MGU2YjY1LWZkOTgtNDk4Ny1iNWQ3LWQyN2MwOWIxODFhYSIsImZpbGVuYW1lIjoiMjAyMTA0MTUtMTE0MjE2LmNwdHYiLCJtaW1lVHlwZSI6ImFwcGxpY2F0aW9uL3gtY3B0diIsImlhdCI6MTYxODQ2MjUwNiwiZXhwIjoxNjE4NDYzMTA2fQ.p3RAOX7Ns52JqHWTMM5Se-Fn-UCyRtX2tveaGrRmiwo\";\n      this.consumed = false;\n      this.response = await fetch(url);\n      if (this.response.status === 200) {\n        this.reader = this.response.body.getReader();\n        if (!size) {\n          size = Number(this.response.headers.get(\"Content-Length\")) || 0;\n        }\n        this.expectedSize = size;\n        this.playerContext = await cptvPlayer.CptvPlayerContext.newWithStream(this.reader);\n        unlocker.unlock();\n        this.inited = true;\n        this.locked = false;\n        return true;\n      } else {\n        this.locked = false;\n        try {\n          const r = await this.response.json();\n          return (r.messages && r.messages.pop()) || r.message || \"Unknown error\";\n        } catch (e) {\n          return await r.text();\n        }\n      }\n    } catch (e) {\n      this.locked = false;\n      return `Failed to load CPTV url ${url}, ${e}`;\n    }\n  }\n\n  async initWithCptvFile(filePath) {\n    // Don't call this from a browser!\n    const file = await fs.readFile(filePath);\n    const require = createRequire(import.meta.url);\n    const path = require.resolve(\"./pkg/index_bg.wasm\");\n    const wasm = await fs.readFile(path);\n    return this.initWithFileBytes(file, filePath, wasm);\n  }\n\n  async initWithFileBytes(fileBytes, filePath = \"\", wasm) {\n    // Don't call this from a browser!\n    const unlocker = new Unlocker();\n    await this.lockIsUncontended(unlocker);\n    this.locked = true;\n    if (!initedWasm) {\n      await cptvPlayer.default(wasm);\n      initedWasm = true;\n    } else if (initedWasm && this.inited) {\n      this.playerContext.free();\n      this.reader && await this.reader.cancel();\n    }\n    this.consumed = false;\n    this.reader = new FakeReader(fileBytes, 100000);\n    this.expectedSize = fileBytes.length;\n    try {\n      this.playerContext = await cptvPlayer.CptvPlayerContext.newWithStream(this.reader);\n      unlocker.unlock();\n      this.inited = true;\n      this.locked = false;\n      return true;\n    } catch (e) {\n      this.locked = false;\n      return `Failed to load CPTV file ${filePath}, ${e}`;\n    }\n  }\n\n  async fetchNextFrame() {\n    if (!this.reader) {\n      return \"You need to initialise the player with the url of a CPTV file\";\n    }\n    if (this.consumed) {\n      return \"Stream has already been consumed and discarded\";\n    }\n    const unlocker = new Unlocker();\n    await this.lockIsUncontended(unlocker);\n    this.locked = true;\n    if (this.playerContext && this.playerContext.ptr) {\n      this.playerContext = await cptvPlayer.CptvPlayerContext.fetchNextFrame(this.playerContext);\n    }\n    unlocker.unlock();\n    this.locked = false;\n    const frameData = this.playerContext.getNextFrame();\n    if (frameData.length === 0) {\n      return null;\n    }\n    const frameHeader = this.playerContext.getFrameHeader();\n    return { data: new Uint16Array(frameData), meta: frameHeader };\n  }\n\n  async countTotalFrames() {\n    if (!this.reader) {\n      return \"You need to initialise the player with the url of a CPTV file\";\n    }\n    const unlocker = new Unlocker();\n    await this.lockIsUncontended(unlocker);\n    this.locked = true;\n    if (this.playerContext && this.playerContext.ptr) {\n      this.playerContext = await cptvPlayer.CptvPlayerContext.countTotalFrames(this.playerContext);\n      // We can't call any other methods that read frame data on this stream,\n      // since we've exhausted it and thrown away the data after scanning for the info we want.\n      this.consumed = true;\n    }\n    unlocker.unlock();\n    this.locked = false;\n    return this.getTotalFrames();\n  }\n\n  async getMetadata() {\n    const header = await this.getHeader();\n    const totalFrameCount = await this.countTotalFrames();\n    const duration = (1 / header.fps) * totalFrameCount;\n    return {\n      ...header,\n      duration\n    }\n  }\n\n  async getFileMetadata(filePath) {\n    await this.initWithCptvFile(filePath, true);\n    return await this.getMetadata();\n  }\n\n  async getStreamMetadata(url, size) {\n    await this.initWithCptvUrlAndSize(url, size);\n    return await this.getMetadata();\n  }\n\n  async lockIsUncontended(unlocker) {\n    return new Promise((resolve) => {\n      if (this.locked) {\n        unlocker.fn = resolve;\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  async getHeader() {\n    if (!this.reader) {\n      return \"You need to initialise the player with the url of a CPTV file\";\n    }\n    const unlocker = new Unlocker();\n    await this.lockIsUncontended(unlocker);\n    this.locked = true;\n    if (this.playerContext && this.playerContext.ptr) {\n      this.playerContext = await cptvPlayer.CptvPlayerContext.fetchHeader(this.playerContext);\n    }\n    const header = this.playerContext.getHeader();\n    unlocker.unlock();\n    this.locked = false;\n    return header;\n  }\n\n  getTotalFrames() {\n    if (!this.locked && this.inited && this.playerContext.ptr && this.playerContext.streamComplete()) {\n      return this.playerContext.totalFrames();\n    }\n    return null;\n  }\n\n  getLoadProgress() {\n    if (this.locked || (!this.playerContext || !this.playerContext.ptr)) {\n      return null;\n    }\n    // This doesn't actually tell us how much has downloaded, just how much has been lazily read.\n    return this.playerContext.bytesLoaded() / this.expectedSize;\n  }\n}\n","import {CptvDecoderInterface} from \"./decoder.js\";\nimport {parentPort} from \"worker_threads\";\nconst context = parentPort || (typeof self !== \"undefined\" ? self : false);\nif (context) {\n  const player = new CptvDecoderInterface();\n  context.addEventListener(\"message\", async ({data}) => {\n    switch (data.type) {\n      case \"initWithUrl\": {\n        const result = await player.initWithCptvUrlAndSize(data.url);\n        context.postMessage({type: data.type, data: result});\n      }\n        break;\n      case \"initWithUrlAndSize\": {\n        const result = await player.initWithCptvUrlAndSize(data.url, data.size);\n        context.postMessage({type: data.type, data: result});\n      }\n        break;\n      case \"initWithPath\": {\n        const result = await player.initWithCptvFile(data.path);\n        context.postMessage({type: data.type, data: result});\n      }\n        break;\n      case \"initWithLocalCptvFile\": {\n        const result = await player.initWithFileBytes(data.arrayBuffer);\n        context.postMessage({type: data.type, data: result});\n      }\n        break;\n      case \"getFileMetadata\": {\n        const header = await player.getFileMetadata(data.path);\n        context.postMessage({type: data.type, data: header});\n      }\n        break;\n      case \"getStreamMetadata\": {\n        const header = await player.getStreamMetadata(data.url);\n        context.postMessage({type: data.type, data: header});\n      }\n        break;\n      case \"getNextFrame\": {\n        const frame = await player.fetchNextFrame();\n        context.postMessage({type: data.type, data: frame});\n      }\n        break;\n      case \"getTotalFrames\": {\n        const totalFrames = player.getTotalFrames();\n        context.postMessage({type: data.type, data: totalFrames});\n      }\n        break;\n      case \"getLoadProgress\": {\n        const progress = player.getLoadProgress();\n        context.postMessage({type: data.type, data: progress});\n      }\n        break;\n      case \"getHeader\": {\n        const header = await player.getHeader();\n        context.postMessage({type: data.type, data: header});\n      }\n        break;\n      default:\n        context.postMessage(data);\n        return;\n    }\n  });\n}\nexport default () => {\n  return false;\n};\n"],"sourceRoot":""}