{"version":3,"sources":["webpack://CptvPlayerVue/../cptv-rs/decoder.js","webpack://CptvPlayerVue/../cptv-rs/decoder.worker.js"],"names":["Unlocker","this","FakeReader","maxChunkSize","state","offsets","length","bytes","numParts","Math","percentages","i","read","Promise","value","resolve","done","cancel","initedWasm","CptvDecoderInterface","CptvPlayerContext","reader","unlocker","lockIsUncontended","initWasm","fetch","response","status","body","size","Number","headers","get","r","fs","file","initWithFileBytes","filePath","isNode","fileBytes","console","playerContext","frameData","frameHeader","sameFrameAsPrev","prevFrameHeader","getTotalFrames","data","Uint16Array","meta","header","totalFrameCount","duration","totalFrames","initWithCptvFile","initWithCptvUrlAndSize","url","locked","bytesLoaded","streamError","context","parentPort","self","player","result","type","frame","progress","hasError","error"],"mappings":"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","file":"CptvPlayerVue.umd.min.251.js","sourcesContent":["let CptvPlayerContext;\n\n/**\n * NOTE: For browser usage, these imports need to be stubbed\n *  out in your webpack config using:\n *\n * resolve: {\n *  fallback: {\n *    fs\n *  }\n * }\n */\n\nimport fs from \"fs/promises\";\n\nclass Unlocker {\n  constructor() {\n    this.fn = null;\n  }\n  unlock() {\n    this.fn && this.fn();\n  }\n}\n\n// For use in nodejs to wrap an already loaded array buffer into a Reader interface\nconst FakeReader = function (bytes, maxChunkSize = 0) {\n  const state = {\n    offsets: []\n  };\n  state.bytes = bytes;\n  state.offset = 0;\n  const length = bytes.byteLength;\n  // How many reader chunks to split the file into\n  let numParts = 5;\n  if (maxChunkSize !== 0) {\n    numParts = Math.ceil(length / maxChunkSize);\n  }\n  const percentages = length / numParts;\n  for (let i = 0; i < numParts; i++) {\n    state.offsets.push(Math.ceil(percentages * i));\n  }\n  state.offsets.push(length);\n  return {\n    read() {\n      return new Promise((resolve) => {\n        state.offset += 1;\n        const value = state.bytes.slice(state.offsets[state.offset - 1], state.offsets[state.offset]);\n        resolve({\n          value,\n          done: state.offset === state.offsets.length - 1\n        });\n      });\n    },\n    cancel() {\n      // Does nothing.\n      return new Promise((resolve) => {\n        resolve()\n      });\n    }\n  }\n};\n\n// TODO(jon): This differs depending on whether the sensor is lepton 3 or 3.5\n// TODO(jon): This is probably out of scope for this library, should be handled\n//  at the player level.\nlet initedWasm = false;\n\nexport class CptvDecoderInterface {\n  async initWasm(isNode) {\n    if (!initedWasm) {\n      if (isNode) {\n        CptvPlayerContext = (await import(\"./pkg-node/index.js\")).CptvPlayerContext;\n      } else {\n        CptvPlayerContext = (await import (\"./pkg/index.js\")).CptvPlayerContext;\n      }\n      initedWasm = true;\n    }\n    else if (initedWasm && this.inited) {\n      this.playerContext.free();\n      this.reader && await this.reader.cancel();\n    }\n  }\n\n  async initWithCptvUrlAndSize(url, size) {\n    const unlocker = new Unlocker();\n    await this.lockIsUncontended(unlocker);\n    this.locked = true;\n    this.framesRead = 0;\n    this.prevFrameHeader = null;\n    this.streamError = undefined;\n    await this.initWasm(false);\n    try {\n      // Use this expired JWT token to test that failure case (usually when a page has been open too long)\n      // const oldJWT = \"https://api.cacophony.org.nz/api/v1/signedUrl?jwt=eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJfdHlwZSI6ImZpbGVEb3dubG9hZCIsImtleSI6InJhdy8yMDIxLzA0LzE1LzQ3MGU2YjY1LWZkOTgtNDk4Ny1iNWQ3LWQyN2MwOWIxODFhYSIsImZpbGVuYW1lIjoiMjAyMTA0MTUtMTE0MjE2LmNwdHYiLCJtaW1lVHlwZSI6ImFwcGxpY2F0aW9uL3gtY3B0diIsImlhdCI6MTYxODQ2MjUwNiwiZXhwIjoxNjE4NDYzMTA2fQ.p3RAOX7Ns52JqHWTMM5Se-Fn-UCyRtX2tveaGrRmiwo\";\n      this.consumed = false;\n      this.response = await fetch(url);\n      if (this.response.status === 200) {\n        this.reader = this.response.body.getReader();\n        if (!size) {\n          size = Number(this.response.headers.get(\"Content-Length\")) || 0;\n        }\n        this.expectedSize = size;\n        this.playerContext = await CptvPlayerContext.newWithStream(this.reader);\n        unlocker.unlock();\n        this.inited = true;\n        this.locked = false;\n        return true;\n      } else {\n        unlocker.unlock();\n        this.locked = false;\n        try {\n          const r = await this.response.json();\n          return (r.messages && r.messages.pop()) || r.message || \"Unknown error\";\n        } catch (e) {\n          return await r.text();\n        }\n      }\n    } catch (e) {\n      this.locked = false;\n      return `Failed to load CPTV url ${url}, ${e}`;\n    }\n  }\n\n  async initWithCptvFile(filePath) {\n    // Don't call this from a browser!\n    const file = await fs.readFile(filePath);\n    return this.initWithFileBytes(file, filePath, true);\n  }\n\n  async initWithFileBytes(fileBytes, filePath = \"\", isNode = false) {\n    // Don't call this from a browser!\n    this.framesRead = 0;\n    this.streamError = undefined;\n    const unlocker = new Unlocker();\n    await this.lockIsUncontended(unlocker);\n    this.prevFrameHeader = null;\n    this.locked = true;\n    await this.initWasm(isNode);\n    this.consumed = false;\n    this.reader = new FakeReader(fileBytes, 100000);\n    this.expectedSize = fileBytes.length;\n    try {\n      this.playerContext = await CptvPlayerContext.newWithStream(this.reader);\n      unlocker.unlock();\n      this.inited = true;\n      this.locked = false;\n      return true;\n    } catch (e) {\n      this.streamError = e;\n      unlocker.unlock();\n      this.locked = false;\n      return `Failed to load CPTV file ${filePath}, ${e}`;\n    }\n  }\n\n  async fetchNextFrame() {\n    if (!this.reader) {\n      console.warn(\"You need to initialise the player with the url of a CPTV file\");\n      return null;\n    }\n    if (this.consumed) {\n      console.warn(\"Stream has already been consumed and discarded\");\n      return null;\n    }\n    const unlocker = new Unlocker();\n    await this.lockIsUncontended(unlocker);\n    this.locked = true;\n    if (this.playerContext && this.playerContext.ptr) {\n      try {\n        this.playerContext = await CptvPlayerContext.fetchNextFrame(this.playerContext);\n      } catch (e) {\n        this.streamError = e;\n      }\n    } else {\n      console.warn(\"Fetch next failed\");\n    }\n    unlocker.unlock();\n    this.locked = false;\n    if (this.hasStreamError()) {\n      return null;\n    }\n    const frameData = this.playerContext.getNextFrame();\n    const frameHeader = this.playerContext.getFrameHeader();\n    // NOTE(jon): Work around a bug where the mlx sensor doesn't report timeOn times, just hardcodes 60000\n    if (frameHeader && frameHeader.imageData.width !== 32) {\n      const sameFrameAsPrev = frameHeader && this.prevFrameHeader && frameHeader.timeOnMs === this.prevFrameHeader.timeOnMs;\n      if (sameFrameAsPrev && this.getTotalFrames() === null) {\n        this.prevFrameHeader = frameHeader;\n        return await this.fetchNextFrame();\n      }\n      this.prevFrameHeader = frameHeader;\n    }\n    if (frameData.length === 0) {\n      return null;\n    }\n    this.framesRead++;\n    return { data: new Uint16Array(frameData), meta: frameHeader };\n  }\n\n  async countTotalFrames() {\n    if (!this.reader) {\n      console.warn(\"You need to initialise the player with the url of a CPTV file\");\n      return 0;\n    }\n    const unlocker = new Unlocker();\n    await this.lockIsUncontended(unlocker);\n    this.locked = true;\n    if (this.playerContext && this.playerContext.ptr) {\n      try {\n        this.playerContext = await CptvPlayerContext.countTotalFrames(this.playerContext);\n      } catch (e) {\n        this.streamError = e;\n      }\n      // We can't call any other methods that read frame data on this stream,\n      // since we've exhausted it and thrown away the data after scanning for the info we want.\n      this.consumed = true;\n    }\n    unlocker.unlock();\n    this.locked = false;\n    return this.getTotalFrames();\n  }\n\n  async getMetadata() {\n    const header = await this.getHeader();\n    let totalFrameCount = 0;\n    if (this.hasStreamError()) {\n      return this.streamError;\n    } else {\n      totalFrameCount = await this.countTotalFrames();\n      const duration = (1 / header.fps) * totalFrameCount;\n      return {\n        ...header,\n        duration,\n        totalFrames: totalFrameCount,\n      }\n    }\n  }\n\n  async getBytesMetadata(fileBytes) {\n    await this.initWithFileBytes(fileBytes, \"\", !!fs);\n    return await this.getMetadata();\n  }\n\n  async getFileMetadata(filePath) {\n    await this.initWithCptvFile(filePath);\n    return await this.getMetadata();\n  }\n\n  async getStreamMetadata(url, size) {\n    await this.initWithCptvUrlAndSize(url, size);\n    return await this.getMetadata();\n  }\n\n  async lockIsUncontended(unlocker) {\n    return new Promise((resolve) => {\n      if (this.locked) {\n        unlocker.fn = resolve;\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  async getHeader() {\n    if (!this.reader) {\n      return \"You need to initialise the player with the url of a CPTV file\";\n    }\n    const unlocker = new Unlocker();\n    await this.lockIsUncontended(unlocker);\n    this.locked = true;\n    if (this.playerContext && this.playerContext.ptr) {\n      this.playerContext = await CptvPlayerContext.fetchHeader(this.playerContext);\n    }\n    if (this.playerContext && this.playerContext.ptr) {\n      const header = this.playerContext.getHeader();\n      if (header === \"Unable to parse header\") {\n        this.streamError = header;\n      }\n      unlocker.unlock();\n      this.locked = false;\n      return header;\n    }\n    return this.streamError;\n  }\n\n  getTotalFrames() {\n    if (this.streamError) {\n      return this.framesRead;\n    }\n    if (!this.locked && this.inited && this.playerContext.ptr && this.playerContext.streamComplete()) {\n      return this.playerContext.totalFrames();\n    }\n    return null;\n  }\n\n  getLoadProgress() {\n    if (this.locked || (!this.playerContext || !this.playerContext.ptr)) {\n      return null;\n    }\n    // This doesn't actually tell us how much has downloaded, just how much has been lazily read.\n    return this.playerContext.bytesLoaded() / this.expectedSize;\n  }\n\n  hasStreamError() {\n    return this.streamError !== undefined;\n  }\n}\n","import {CptvDecoderInterface} from \"./decoder.js\";\nimport {parentPort} from \"worker_threads\";\nconst context = parentPort || (typeof self !== \"undefined\" ? self : false);\nif (context) {\n  const player = new CptvDecoderInterface();\n  context.addEventListener(\"message\", async ({data}) => {\n    switch (data.type) {\n      case \"initWithUrl\": {\n        const result = await player.initWithCptvUrlAndSize(data.url);\n        context.postMessage({type: data.type, data: result});\n      }\n        break;\n      case \"initWithUrlAndSize\": {\n        const result = await player.initWithCptvUrlAndSize(data.url, data.size);\n        context.postMessage({type: data.type, data: result});\n      }\n        break;\n      case \"initWithPath\": {\n        const result = await player.initWithCptvFile(data.path);\n        context.postMessage({type: data.type, data: result});\n      }\n        break;\n      case \"initWithLocalCptvFile\": {\n        const result = await player.initWithFileBytes(data.arrayBuffer);\n        context.postMessage({type: data.type, data: result});\n      }\n        break;\n      case \"getBytesMetadata\": {\n        const header = await player.getBytesMetadata(data.arrayBuffer);\n        context.postMessage({type: data.type, data: header});\n      }\n        break;\n      case \"getFileMetadata\": {\n        const header = await player.getFileMetadata(data.path);\n        context.postMessage({type: data.type, data: header});\n      }\n        break;\n      case \"getStreamMetadata\": {\n        const header = await player.getStreamMetadata(data.url);\n        context.postMessage({type: data.type, data: header});\n      }\n        break;\n      case \"getNextFrame\": {\n        const frame = await player.fetchNextFrame();\n        context.postMessage({type: data.type, data: frame});\n      }\n        break;\n      case \"getTotalFrames\": {\n        const totalFrames = player.getTotalFrames();\n        context.postMessage({type: data.type, data: totalFrames});\n      }\n        break;\n      case \"getLoadProgress\": {\n        const progress = player.getLoadProgress();\n        context.postMessage({type: data.type, data: progress});\n      }\n        break;\n      case \"getHeader\": {\n        const header = await player.getHeader();\n        context.postMessage({type: data.type, data: header});\n      }\n        break\n      case \"hasStreamError\": {\n        const hasError = player.hasStreamError();\n        context.postMessage({type: data.type, data: hasError });\n      }\n        break;\n      case \"getStreamError\": {\n        const error = player.streamError;\n        context.postMessage({type: data.type, data: error });\n      }\n        break;\n      default:\n        context.postMessage(data);\n        return;\n    }\n  });\n}\nexport default () => {\n  return false;\n};\n"],"sourceRoot":""}